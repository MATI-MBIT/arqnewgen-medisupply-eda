apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "mqtt-kafka-bridge.fullname" . }}
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "mqtt-kafka-bridge.labels" . | nindent 4 }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      {{- include "mqtt-kafka-bridge.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      labels:
        {{- include "mqtt-kafka-bridge.selectorLabels" . | nindent 8 }}
        app: mqtt-kafka-bridge
        version: v1
    spec:
      initContainers:
      - name: install-deps
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
        command:
        - sh
        - -c
        - |
          pip install kafka-python paho-mqtt
          cp -r /usr/local/lib/python3.11/site-packages/* /shared/
        volumeMounts:
        - name: shared-libs
          mountPath: /shared
      containers:
      - name: bridge
        image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
        imagePullPolicy: {{ .Values.image.pullPolicy }}
        command:
        - python
        - -c
        - |
          import json
          import time
          import logging
          import os
          from kafka import KafkaProducer
          import paho.mqtt.client as mqtt
          
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)
          
          # Configuration from environment variables
          mqtt_topics_env = os.getenv('MQTT_TOPICS', '')
          kafka_topic_prefix = os.getenv('KAFKA_TOPIC_PREFIX', '')
          topic_mapping_env = os.getenv('TOPIC_MAPPING', '{}')
          preserve_topic_names = os.getenv('PRESERVE_TOPIC_NAMES', 'true').lower() == 'true'
          
          # Parse topics and mapping
          mqtt_topics = [t.strip() for t in mqtt_topics_env.split(',') if t.strip()]
          try:
              topic_mapping = json.loads(topic_mapping_env)
          except:
              topic_mapping = {}
          
          logger.info(f"MQTT Topics to subscribe: {mqtt_topics}")
          logger.info(f"Topic mapping: {topic_mapping}")
          logger.info(f"Preserve topic names: {preserve_topic_names}")
          logger.info(f"Kafka topic prefix: {kafka_topic_prefix}")
          
          # Kafka producer
          producer = KafkaProducer(
              bootstrap_servers=['{{ .Values.kafka.bootstrapServers }}'],
              value_serializer=lambda v: json.dumps(v).encode('utf-8'),
              retries=3,
              retry_backoff_ms=1000
          )
          
          def get_kafka_topic(mqtt_topic):
              # Check custom mapping first
              if mqtt_topic in topic_mapping:
                  return topic_mapping[mqtt_topic]
              
              # Use original topic name with optional prefix
              if preserve_topic_names:
                  return f"{kafka_topic_prefix}{mqtt_topic}" if kafka_topic_prefix else mqtt_topic
              
              # Default fallback
              return f"{kafka_topic_prefix}mqtt-events"
          
          def on_connect(client, userdata, flags, rc):
              logger.info(f"Connected to MQTT broker with result code {rc}")
              for topic in mqtt_topics:
                  client.subscribe(topic)
                  logger.info(f"Subscribed to MQTT topic: {topic}")
          
          def on_message(client, userdata, msg):
              try:
                  message = msg.payload.decode('utf-8')
                  mqtt_topic = msg.topic
                  kafka_topic = get_kafka_topic(mqtt_topic)
                  
                  logger.info(f"Received MQTT message from {mqtt_topic}: {message}")
                  
                  # Send to Kafka
                  kafka_message = {
                      'mqtt_topic': mqtt_topic,
                      'payload': message,
                      'timestamp': time.time()
                  }
                  
                  producer.send(kafka_topic, kafka_message)
                  producer.flush()
                  logger.info(f"Sent message to Kafka topic: {kafka_topic}")
              except Exception as e:
                  logger.error(f"Error processing message: {e}")
          
          # MQTT client
          client = mqtt.Client()
          client.on_connect = on_connect
          client.on_message = on_message
          
          logger.info("Connecting to MQTT broker...")
          client.connect("{{ .Values.mqtt.broker }}", {{ .Values.mqtt.port }}, 60)
          
          logger.info("Starting MQTT-Kafka bridge...")
          client.loop_forever()
        env:
        - name: PYTHONUNBUFFERED
          value: "1"
        - name: PYTHONPATH
          value: "/shared"
        - name: MQTT_TOPICS
          value: "{{ join "," .Values.mqtt.topics }}"
        - name: PRESERVE_TOPIC_NAMES
          value: "{{ .Values.kafka.preserveTopicNames }}"
        - name: KAFKA_TOPIC_PREFIX
          value: "{{ .Values.kafka.topicPrefix }}"
        - name: TOPIC_MAPPING
          value: {{ .Values.kafka.topicMapping | toJson | quote }}
        volumeMounts:
        - name: shared-libs
          mountPath: /shared
        resources:
          {{- toYaml .Values.resources | nindent 10 }}
        livenessProbe:
          exec:
            command:
            - python
            - -c
            - "import socket; s=socket.socket(); s.connect(('{{ .Values.mqtt.broker }}', {{ .Values.mqtt.port }})); s.close()"
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          exec:
            command:
            - python
            - -c
            - "import socket; s=socket.socket(); s.connect(('{{ .Values.mqtt.broker }}', {{ .Values.mqtt.port }})); s.close()"
          initialDelaySeconds: 10
          periodSeconds: 10
      volumes:
      - name: shared-libs
        emptyDir: {}
